<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>xswap.prior API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>xswap.prior</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">from typing import List, Tuple

import numpy
import pandas
import scipy.sparse

import xswap.network_formats


def compute_xswap_occurrence_matrix(edge_list: List[Tuple[int, int]],
                                    n_permutations: int,
                                    shape: Tuple[int, int],
                                    allow_self_loops: bool = False,
                                    allow_antiparallel: bool = False,
                                    swap_multiplier: float = 10,
                                    initial_seed: int = 0,
                                    max_malloc: int = 4000000000):
    &#34;&#34;&#34;
    Compute the XSwap prior probability for every node pair in a network. The
    XSwap prior is the probability of a node pair having an edge between them in
    degree-preserving permutations of a network. The prior value for a node
    pair can be considered as the probability of an edge existing between two
    nodes given only the network&#39;s degree sequence.

    Parameters
    ----------
    edge_list : List[Tuple[int, int]]
        Edge list representing the graph whose XSwap edge priors are to be
        computed. Tuples contain integer values representing nodes. No value
        should be greater than C++&#39;s `INT_MAX`, in this case 2_147_483_647.
        An adjacency matrix will be created assuming that a node&#39;s value is its
        index in the matrix. If not, map edges (identifiers can be string or
        otherwise) using `xswap.preprocessing.map_str_edges`.
    n_permutations : int
        The number of permuted networks used to compute the empirical XSwap prior
    shape : Tuple[int, int]
        The shape of the matrix to be returned. In other words, a tuple of the
        number of source and target nodes.
    allow_self_loops : bool
        Whether to allow edges like (0, 0). In the case of bipartite graphs,
        such an edge represents a connection between two distinct nodes, while
        in other graphs it may represent an edge from a node to itself, in which
        case an edge may or may not be meaningful depending on context.
    allow_antiparallel : bool
        Whether to allow simultaneous edges like (0, 1) and (1, 0). In the case
        of bipartite graphs, these edges represent two connections between four
        distinct nodes, while for other graphs, these may be connections between
        the same two nodes.
    swap_multiplier : float
        The number of edge swap attempts is determined by the product of the
        number of existing edges and multiplier. For example, if five edges are
        passed and multiplier is set to 10, 50 swaps will be attempted. Non-integer
        products will be rounded down to the nearest integer.
    initial_seed : int
        Random seed that will be passed to the C++ Mersenne Twister 19937 random
        number generator. `initial_seed` will be used for the first permutation,
        and the seed used for each subsequent permutation will be incremented by
        one. For example, if `initial_seed` is 0 and `n_permutations` is 2, then
        the two permutations will pass seeds 0 and 1, respectively.
    max_malloc : int (`unsigned long long int` in C)
        The maximum amount of memory to be allocated using `malloc` when making
        a bitset to hold edges. An uncompressed bitset is implemented for
        holding edges that is significantly faster than alternatives. However,
        it is memory-inefficient and will not be used if more memory is required
        than `max_malloc`. Above the threshold, a Roaring bitset will be used.

    Returns
    -------
    edge_counter : scipy.sparse.csc_matrix
        Adjacency matrix with entries equal to the number of permutations in
        which a given edge appeared
    &#34;&#34;&#34;
    import xswap._xswap_backend
    if len(edge_list) != len(set(edge_list)):
        raise ValueError(&#34;Edge list contained duplicate edges. &#34;
                         &#34;XSwap does not support multigraphs.&#34;)

    num_swaps = int(swap_multiplier * len(edge_list))

    max_id = max(map(max, edge_list))

    edge_counter = scipy.sparse.csc_matrix(shape, dtype=int)

    for i in range(n_permutations):
        permuted_edges, stats = xswap._xswap_backend._xswap(
            edge_list, [], max_id, allow_self_loops, allow_antiparallel,
            num_swaps, initial_seed + i, max_malloc)
        permuted_matrix = xswap.network_formats.edges_to_matrix(
            permuted_edges, add_reverse_edges=(not allow_antiparallel),
            shape=shape, dtype=int, sparse=True)
        edge_counter += permuted_matrix

    return edge_counter


def compute_xswap_priors(edge_list: List[Tuple[int, int]], n_permutations: int,
                         shape: Tuple[int, int], allow_self_loops: bool = False,
                         allow_antiparallel: bool = False,
                         swap_multiplier: int = 10, initial_seed: int = 0,
                         max_malloc: int = 4000000000,
                         dtypes = {&#39;id&#39;: numpy.uint16, &#39;degree&#39;: numpy.uint16,
                                   &#39;edge&#39;: bool, &#39;xswap_prior&#39;: float},
                        ):
    &#34;&#34;&#34;
    Compute the XSwap prior for every potential edge in the network. Uses
    degree-grouping to maximize the effective number of permutations for each
    node pair. That is, node pairs with the same source and target degrees can
    be grouped when computing the XSwap prior, allowing there to be more
    permutations for some node pairs than `n_permutations`.

    Note that the mechanics of this function are separated to minimize memory use.

    Parameters
    ----------
    edge_list : List[Tuple[int, int]]
        Edge list representing the graph whose XSwap edge priors are to be
        computed. Tuples contain integer values representing nodes. No value
        should be greater than C++&#39;s `INT_MAX`, in this case 2_147_483_647.
        An adjacency matrix will be created assuming that a node&#39;s value is its
        index in the matrix. If not, map edges (identifiers can be string or
        otherwise) using `xswap.preprocessing.map_str_edges`.
    n_permutations : int
        The number of permuted networks used to compute the empirical XSwap prior
    shape : Tuple[int, int]
        The shape of the matrix to be returned. In other words, a tuple of the
        number of source and target nodes.
    allow_self_loops : bool
        Whether to allow edges like (0, 0). In the case of bipartite graphs,
        such an edge represents a connection between two distinct nodes, while
        in other graphs it may represent an edge from a node to itself, in which
        case an edge may or may not be meaningful depending on context.
    allow_antiparallel : bool
        Whether to allow simultaneous edges like (0, 1) and (1, 0). In the case
        of bipartite graphs, these edges represent two connections between four
        distinct nodes, while for other graphs, these may be connections between
        the same two nodes.
    swap_multiplier : float
        The number of edge swap attempts is determined by the product of the
        number of existing edges and multiplier. For example, if five edges are
        passed and multiplier is set to 10, 50 swaps will be attempted. Non-integer
        products will be rounded down to the nearest integer.
    initial_seed : int
        Random seed that will be passed to the C++ Mersenne Twister 19937 random
        number generator. `initial_seed` will be used for the first permutation,
        and the seed used for each subsequent permutation will be incremented by
        one. For example, if `initial_seed` is 0 and `n_permutations` is 2, then
        the two permutations will pass seeds 0 and 1, respectively.
    max_malloc : int (`unsigned long long int` in C)
        The maximum amount of memory to be allocated using `malloc` when making
        a bitset to hold edges. An uncompressed bitset is implemented for
        holding edges that is significantly faster than alternatives. However,
        it is memory-inefficient and will not be used if more memory is required
        than `max_malloc`. Above the threshold, a Roaring bitset will be used.
    dtypes : dict
        Dictionary mapping returned column types to dtypes. Keys should be
        `&#39;id&#39;`, `&#39;degree&#39;`, `&#39;edge&#39;`, and `&#39;xswap_prior&#39;`. `dtype` need only
        be changed from its defaults if the values of `id` or `degree` are
        greater than the maxima in the default dtypes, or in cases where greater
        precision is desired. (`numpy.uint16` has a maximum value of 65535.)

    Returns
    -------
    prior_df : pandas.DataFrame
        Columns are the following:
        [source_id, target_id, edge, source_degree, target_degree, xswap_prior]
    &#34;&#34;&#34;
    # Compute the adjacency matrix of the original (unpermuted) network
    original_edges = xswap.network_formats.edges_to_matrix(
        edge_list, add_reverse_edges=(not allow_antiparallel), shape=shape,
        dtype=dtypes[&#39;edge&#39;], sparse=True)

    # Setup DataFrame for recording prior data
    prior_df = pandas.DataFrame({
        &#39;source_id&#39;: numpy.repeat(numpy.arange(shape[0], dtype=dtypes[&#39;id&#39;]), shape[1]),
        &#39;target_id&#39;: numpy.tile(numpy.arange(shape[1], dtype=dtypes[&#39;id&#39;]), shape[0]),
        &#39;edge&#39;: original_edges.toarray().flatten(),
    })
    del original_edges

    prior_df[&#39;source_degree&#39;] = (prior_df
                                 .groupby(&#39;source_id&#39;)
                                 .transform(sum)[&#39;edge&#39;]
                                 .astype(dtypes[&#39;degree&#39;]))
    del prior_df[&#39;source_id&#39;]

    prior_df[&#39;target_degree&#39;] = (prior_df
                                 .groupby(&#39;target_id&#39;)
                                 .transform(sum)[&#39;edge&#39;]
                                 .astype(dtypes[&#39;degree&#39;]))
    del prior_df[&#39;target_id&#39;]

    # Compute the number of occurrences of each edge across permutations
    edge_counter = compute_xswap_occurrence_matrix(
        edge_list=edge_list, n_permutations=n_permutations, shape=shape,
        allow_self_loops=allow_self_loops, allow_antiparallel=allow_antiparallel,
        swap_multiplier=swap_multiplier, initial_seed=initial_seed,
        max_malloc=max_malloc)

    prior_df[&#39;num_permuted_edges&#39;] = edge_counter.toarray().flatten()
    del edge_counter

    # The number of edges that occurred across all node pairs with the same
    # `source_degree` and `target_degree`
    dgp_edge_count = (
        prior_df
        .groupby([&#39;source_degree&#39;, &#39;target_degree&#39;])
        .transform(sum)[&#39;num_permuted_edges&#39;]
        .values
        .astype(dtypes[&#39;degree&#39;])
    )
    del prior_df[&#39;num_permuted_edges&#39;]

    # The effective number of permutations for every node pair, incorporating
    # degree-grouping
    num_dgp = (
        n_permutations * prior_df.groupby([&#39;source_degree&#39;, &#39;target_degree&#39;])
                                 .transform(len)[&#39;edge&#39;]
                                 .values
    )
    xswap_prior = (dgp_edge_count / num_dgp).astype(dtypes[&#39;xswap_prior&#39;])
    del dgp_edge_count, num_dgp

    prior_df[&#39;xswap_prior&#39;] = xswap_prior
    del xswap_prior

    prior_df = (
        prior_df
        .assign(
            source_id=numpy.repeat(numpy.arange(shape[0], dtype=dtypes[&#39;id&#39;]), shape[1]),
            target_id=numpy.tile(numpy.arange(shape[1], dtype=dtypes[&#39;id&#39;]), shape[0]),
        )
        .filter(items=[&#39;source_id&#39;, &#39;target_id&#39;, &#39;edge&#39;, &#39;source_degree&#39;,
                       &#39;target_degree&#39;, &#39;xswap_prior&#39;])
    )
    return prior_df


def approximate_xswap_prior(source_degree, target_degree, num_edges):
    &#34;&#34;&#34;
    Approximate the XSwap prior by assuming that the XSwap Markov Chain is stationary.
    While this is not the case in reality, some networks&#39; priors can be estimated
    very well using this equation.

    Parameters
    ----------
    source_degree : int, float, numpy.array, or pandas.Series
        The source degree for a single node pair or a number of source degrees.
        The type of object passed should match `target_degree`.
    target_degree : int, float, numpy.array, or pandas.Series
        The target degree for a single node pair or a number of target degrees.
        The type of object passed should match `source_degree`.
    num_edges : int or float
        The total number of edges in the network

    Returns
    -------
    approximate_prior : float, numpy.array, or pandas.Series
        Output type matches the types of `source_degree` and `target_degree`.
    &#34;&#34;&#34;
    return source_degree * target_degree / (
        (source_degree * target_degree) ** 2
        + (num_edges - source_degree - target_degree + 1) ** 2
    ) ** 0.5</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="xswap.prior.approximate_xswap_prior"><code class="name flex">
<span>def <span class="ident">approximate_xswap_prior</span></span>(<span>source_degree, target_degree, num_edges)</span>
</code></dt>
<dd>
<section class="desc"><p>Approximate the XSwap prior by assuming that the XSwap Markov Chain is stationary.
While this is not the case in reality, some networks' priors can be estimated
very well using this equation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>source_degree</code></strong> :&ensp;<code>int</code>, <code>float</code>, <code>numpy.array</code>, or <code>pandas.Series</code></dt>
<dd>The source degree for a single node pair or a number of source degrees.
The type of object passed should match <code>target_degree</code>.</dd>
<dt><strong><code>target_degree</code></strong> :&ensp;<code>int</code>, <code>float</code>, <code>numpy.array</code>, or <code>pandas.Series</code></dt>
<dd>The target degree for a single node pair or a number of target degrees.
The type of object passed should match <code>source_degree</code>.</dd>
<dt><strong><code>num_edges</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>The total number of edges in the network</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>approximate_prior</code></strong> :&ensp;<code>float</code>, <code>numpy.array</code>, or <code>pandas.Series</code></dt>
<dd>Output type matches the types of <code>source_degree</code> and <code>target_degree</code>.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def approximate_xswap_prior(source_degree, target_degree, num_edges):
    &#34;&#34;&#34;
    Approximate the XSwap prior by assuming that the XSwap Markov Chain is stationary.
    While this is not the case in reality, some networks&#39; priors can be estimated
    very well using this equation.

    Parameters
    ----------
    source_degree : int, float, numpy.array, or pandas.Series
        The source degree for a single node pair or a number of source degrees.
        The type of object passed should match `target_degree`.
    target_degree : int, float, numpy.array, or pandas.Series
        The target degree for a single node pair or a number of target degrees.
        The type of object passed should match `source_degree`.
    num_edges : int or float
        The total number of edges in the network

    Returns
    -------
    approximate_prior : float, numpy.array, or pandas.Series
        Output type matches the types of `source_degree` and `target_degree`.
    &#34;&#34;&#34;
    return source_degree * target_degree / (
        (source_degree * target_degree) ** 2
        + (num_edges - source_degree - target_degree + 1) ** 2
    ) ** 0.5</code></pre>
</details>
</dd>
<dt id="xswap.prior.compute_xswap_occurrence_matrix"><code class="name flex">
<span>def <span class="ident">compute_xswap_occurrence_matrix</span></span>(<span>edge_list, n_permutations, shape, allow_self_loops=False, allow_antiparallel=False, swap_multiplier=10, initial_seed=0, max_malloc=4000000000)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute the XSwap prior probability for every node pair in a network. The
XSwap prior is the probability of a node pair having an edge between them in
degree-preserving permutations of a network. The prior value for a node
pair can be considered as the probability of an edge existing between two
nodes given only the network's degree sequence.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>edge_list</code></strong> :&ensp;<code>List</code>[<code>Tuple</code>[<code>int</code>, <code>int</code>]]</dt>
<dd>Edge list representing the graph whose XSwap edge priors are to be
computed. Tuples contain integer values representing nodes. No value
should be greater than C++'s <code>INT_MAX</code>, in this case 2_147_483_647.
An adjacency matrix will be created assuming that a node's value is its
index in the matrix. If not, map edges (identifiers can be string or
otherwise) using <a title="xswap.preprocessing.map_str_edges" href="preprocessing.html#xswap.preprocessing.map_str_edges"><code>map_str_edges()</code></a>.</dd>
<dt><strong><code>n_permutations</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of permuted networks used to compute the empirical XSwap prior</dd>
<dt><strong><code>shape</code></strong> :&ensp;<code>Tuple</code>[<code>int</code>, <code>int</code>]</dt>
<dd>The shape of the matrix to be returned. In other words, a tuple of the
number of source and target nodes.</dd>
<dt><strong><code>allow_self_loops</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to allow edges like (0, 0). In the case of bipartite graphs,
such an edge represents a connection between two distinct nodes, while
in other graphs it may represent an edge from a node to itself, in which
case an edge may or may not be meaningful depending on context.</dd>
<dt><strong><code>allow_antiparallel</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to allow simultaneous edges like (0, 1) and (1, 0). In the case
of bipartite graphs, these edges represent two connections between four
distinct nodes, while for other graphs, these may be connections between
the same two nodes.</dd>
<dt><strong><code>swap_multiplier</code></strong> :&ensp;<code>float</code></dt>
<dd>The number of edge swap attempts is determined by the product of the
number of existing edges and multiplier. For example, if five edges are
passed and multiplier is set to 10, 50 swaps will be attempted. Non-integer
products will be rounded down to the nearest integer.</dd>
<dt><strong><code>initial_seed</code></strong> :&ensp;<code>int</code></dt>
<dd>Random seed that will be passed to the C++ Mersenne Twister 19937 random
number generator. <code>initial_seed</code> will be used for the first permutation,
and the seed used for each subsequent permutation will be incremented by
one. For example, if <code>initial_seed</code> is 0 and <code>n_permutations</code> is 2, then
the two permutations will pass seeds 0 and 1, respectively.</dd>
<dt><strong><code>max_malloc</code></strong> :&ensp;<code>int</code> (<code>unsigned` `long` `long` `int</code> <code>in</code> <code>C</code>)</dt>
<dd>The maximum amount of memory to be allocated using <code>malloc</code> when making
a bitset to hold edges. An uncompressed bitset is implemented for
holding edges that is significantly faster than alternatives. However,
it is memory-inefficient and will not be used if more memory is required
than <code>max_malloc</code>. Above the threshold, a Roaring bitset will be used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>edge_counter</code></strong> :&ensp;<code>scipy.sparse.csc_matrix</code></dt>
<dd>Adjacency matrix with entries equal to the number of permutations in
which a given edge appeared</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def compute_xswap_occurrence_matrix(edge_list: List[Tuple[int, int]],
                                    n_permutations: int,
                                    shape: Tuple[int, int],
                                    allow_self_loops: bool = False,
                                    allow_antiparallel: bool = False,
                                    swap_multiplier: float = 10,
                                    initial_seed: int = 0,
                                    max_malloc: int = 4000000000):
    &#34;&#34;&#34;
    Compute the XSwap prior probability for every node pair in a network. The
    XSwap prior is the probability of a node pair having an edge between them in
    degree-preserving permutations of a network. The prior value for a node
    pair can be considered as the probability of an edge existing between two
    nodes given only the network&#39;s degree sequence.

    Parameters
    ----------
    edge_list : List[Tuple[int, int]]
        Edge list representing the graph whose XSwap edge priors are to be
        computed. Tuples contain integer values representing nodes. No value
        should be greater than C++&#39;s `INT_MAX`, in this case 2_147_483_647.
        An adjacency matrix will be created assuming that a node&#39;s value is its
        index in the matrix. If not, map edges (identifiers can be string or
        otherwise) using `xswap.preprocessing.map_str_edges`.
    n_permutations : int
        The number of permuted networks used to compute the empirical XSwap prior
    shape : Tuple[int, int]
        The shape of the matrix to be returned. In other words, a tuple of the
        number of source and target nodes.
    allow_self_loops : bool
        Whether to allow edges like (0, 0). In the case of bipartite graphs,
        such an edge represents a connection between two distinct nodes, while
        in other graphs it may represent an edge from a node to itself, in which
        case an edge may or may not be meaningful depending on context.
    allow_antiparallel : bool
        Whether to allow simultaneous edges like (0, 1) and (1, 0). In the case
        of bipartite graphs, these edges represent two connections between four
        distinct nodes, while for other graphs, these may be connections between
        the same two nodes.
    swap_multiplier : float
        The number of edge swap attempts is determined by the product of the
        number of existing edges and multiplier. For example, if five edges are
        passed and multiplier is set to 10, 50 swaps will be attempted. Non-integer
        products will be rounded down to the nearest integer.
    initial_seed : int
        Random seed that will be passed to the C++ Mersenne Twister 19937 random
        number generator. `initial_seed` will be used for the first permutation,
        and the seed used for each subsequent permutation will be incremented by
        one. For example, if `initial_seed` is 0 and `n_permutations` is 2, then
        the two permutations will pass seeds 0 and 1, respectively.
    max_malloc : int (`unsigned long long int` in C)
        The maximum amount of memory to be allocated using `malloc` when making
        a bitset to hold edges. An uncompressed bitset is implemented for
        holding edges that is significantly faster than alternatives. However,
        it is memory-inefficient and will not be used if more memory is required
        than `max_malloc`. Above the threshold, a Roaring bitset will be used.

    Returns
    -------
    edge_counter : scipy.sparse.csc_matrix
        Adjacency matrix with entries equal to the number of permutations in
        which a given edge appeared
    &#34;&#34;&#34;
    import xswap._xswap_backend
    if len(edge_list) != len(set(edge_list)):
        raise ValueError(&#34;Edge list contained duplicate edges. &#34;
                         &#34;XSwap does not support multigraphs.&#34;)

    num_swaps = int(swap_multiplier * len(edge_list))

    max_id = max(map(max, edge_list))

    edge_counter = scipy.sparse.csc_matrix(shape, dtype=int)

    for i in range(n_permutations):
        permuted_edges, stats = xswap._xswap_backend._xswap(
            edge_list, [], max_id, allow_self_loops, allow_antiparallel,
            num_swaps, initial_seed + i, max_malloc)
        permuted_matrix = xswap.network_formats.edges_to_matrix(
            permuted_edges, add_reverse_edges=(not allow_antiparallel),
            shape=shape, dtype=int, sparse=True)
        edge_counter += permuted_matrix

    return edge_counter</code></pre>
</details>
</dd>
<dt id="xswap.prior.compute_xswap_priors"><code class="name flex">
<span>def <span class="ident">compute_xswap_priors</span></span>(<span>edge_list, n_permutations, shape, allow_self_loops=False, allow_antiparallel=False, swap_multiplier=10, initial_seed=0, max_malloc=4000000000, dtypes={'id': <class 'numpy.uint16'>, 'degree': <class 'numpy.uint16'>, 'edge': <class 'bool'>, 'xswap_prior': <class 'float'>})</span>
</code></dt>
<dd>
<section class="desc"><p>Compute the XSwap prior for every potential edge in the network. Uses
degree-grouping to maximize the effective number of permutations for each
node pair. That is, node pairs with the same source and target degrees can
be grouped when computing the XSwap prior, allowing there to be more
permutations for some node pairs than <code>n_permutations</code>.</p>
<p>Note that the mechanics of this function are separated to minimize memory use.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>edge_list</code></strong> :&ensp;<code>List</code>[<code>Tuple</code>[<code>int</code>, <code>int</code>]]</dt>
<dd>Edge list representing the graph whose XSwap edge priors are to be
computed. Tuples contain integer values representing nodes. No value
should be greater than C++'s <code>INT_MAX</code>, in this case 2_147_483_647.
An adjacency matrix will be created assuming that a node's value is its
index in the matrix. If not, map edges (identifiers can be string or
otherwise) using <a title="xswap.preprocessing.map_str_edges" href="preprocessing.html#xswap.preprocessing.map_str_edges"><code>map_str_edges()</code></a>.</dd>
<dt><strong><code>n_permutations</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of permuted networks used to compute the empirical XSwap prior</dd>
<dt><strong><code>shape</code></strong> :&ensp;<code>Tuple</code>[<code>int</code>, <code>int</code>]</dt>
<dd>The shape of the matrix to be returned. In other words, a tuple of the
number of source and target nodes.</dd>
<dt><strong><code>allow_self_loops</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to allow edges like (0, 0). In the case of bipartite graphs,
such an edge represents a connection between two distinct nodes, while
in other graphs it may represent an edge from a node to itself, in which
case an edge may or may not be meaningful depending on context.</dd>
<dt><strong><code>allow_antiparallel</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to allow simultaneous edges like (0, 1) and (1, 0). In the case
of bipartite graphs, these edges represent two connections between four
distinct nodes, while for other graphs, these may be connections between
the same two nodes.</dd>
<dt><strong><code>swap_multiplier</code></strong> :&ensp;<code>float</code></dt>
<dd>The number of edge swap attempts is determined by the product of the
number of existing edges and multiplier. For example, if five edges are
passed and multiplier is set to 10, 50 swaps will be attempted. Non-integer
products will be rounded down to the nearest integer.</dd>
<dt><strong><code>initial_seed</code></strong> :&ensp;<code>int</code></dt>
<dd>Random seed that will be passed to the C++ Mersenne Twister 19937 random
number generator. <code>initial_seed</code> will be used for the first permutation,
and the seed used for each subsequent permutation will be incremented by
one. For example, if <code>initial_seed</code> is 0 and <code>n_permutations</code> is 2, then
the two permutations will pass seeds 0 and 1, respectively.</dd>
<dt><strong><code>max_malloc</code></strong> :&ensp;<code>int</code> (<code>unsigned` `long` `long` `int</code> <code>in</code> <code>C</code>)</dt>
<dd>The maximum amount of memory to be allocated using <code>malloc</code> when making
a bitset to hold edges. An uncompressed bitset is implemented for
holding edges that is significantly faster than alternatives. However,
it is memory-inefficient and will not be used if more memory is required
than <code>max_malloc</code>. Above the threshold, a Roaring bitset will be used.</dd>
<dt><strong><code>dtypes</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary mapping returned column types to dtypes. Keys should be
<code>'id'</code>, <code>'degree'</code>, <code>'edge'</code>, and <code>'xswap_prior'</code>. <code>dtype</code> need only
be changed from its defaults if the values of <code>id</code> or <code>degree</code> are
greater than the maxima in the default dtypes, or in cases where greater
precision is desired. (<code>numpy.uint16</code> has a maximum value of 65535.)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>prior_df</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Columns are the following:
[source_id, target_id, edge, source_degree, target_degree, xswap_prior]</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def compute_xswap_priors(edge_list: List[Tuple[int, int]], n_permutations: int,
                         shape: Tuple[int, int], allow_self_loops: bool = False,
                         allow_antiparallel: bool = False,
                         swap_multiplier: int = 10, initial_seed: int = 0,
                         max_malloc: int = 4000000000,
                         dtypes = {&#39;id&#39;: numpy.uint16, &#39;degree&#39;: numpy.uint16,
                                   &#39;edge&#39;: bool, &#39;xswap_prior&#39;: float},
                        ):
    &#34;&#34;&#34;
    Compute the XSwap prior for every potential edge in the network. Uses
    degree-grouping to maximize the effective number of permutations for each
    node pair. That is, node pairs with the same source and target degrees can
    be grouped when computing the XSwap prior, allowing there to be more
    permutations for some node pairs than `n_permutations`.

    Note that the mechanics of this function are separated to minimize memory use.

    Parameters
    ----------
    edge_list : List[Tuple[int, int]]
        Edge list representing the graph whose XSwap edge priors are to be
        computed. Tuples contain integer values representing nodes. No value
        should be greater than C++&#39;s `INT_MAX`, in this case 2_147_483_647.
        An adjacency matrix will be created assuming that a node&#39;s value is its
        index in the matrix. If not, map edges (identifiers can be string or
        otherwise) using `xswap.preprocessing.map_str_edges`.
    n_permutations : int
        The number of permuted networks used to compute the empirical XSwap prior
    shape : Tuple[int, int]
        The shape of the matrix to be returned. In other words, a tuple of the
        number of source and target nodes.
    allow_self_loops : bool
        Whether to allow edges like (0, 0). In the case of bipartite graphs,
        such an edge represents a connection between two distinct nodes, while
        in other graphs it may represent an edge from a node to itself, in which
        case an edge may or may not be meaningful depending on context.
    allow_antiparallel : bool
        Whether to allow simultaneous edges like (0, 1) and (1, 0). In the case
        of bipartite graphs, these edges represent two connections between four
        distinct nodes, while for other graphs, these may be connections between
        the same two nodes.
    swap_multiplier : float
        The number of edge swap attempts is determined by the product of the
        number of existing edges and multiplier. For example, if five edges are
        passed and multiplier is set to 10, 50 swaps will be attempted. Non-integer
        products will be rounded down to the nearest integer.
    initial_seed : int
        Random seed that will be passed to the C++ Mersenne Twister 19937 random
        number generator. `initial_seed` will be used for the first permutation,
        and the seed used for each subsequent permutation will be incremented by
        one. For example, if `initial_seed` is 0 and `n_permutations` is 2, then
        the two permutations will pass seeds 0 and 1, respectively.
    max_malloc : int (`unsigned long long int` in C)
        The maximum amount of memory to be allocated using `malloc` when making
        a bitset to hold edges. An uncompressed bitset is implemented for
        holding edges that is significantly faster than alternatives. However,
        it is memory-inefficient and will not be used if more memory is required
        than `max_malloc`. Above the threshold, a Roaring bitset will be used.
    dtypes : dict
        Dictionary mapping returned column types to dtypes. Keys should be
        `&#39;id&#39;`, `&#39;degree&#39;`, `&#39;edge&#39;`, and `&#39;xswap_prior&#39;`. `dtype` need only
        be changed from its defaults if the values of `id` or `degree` are
        greater than the maxima in the default dtypes, or in cases where greater
        precision is desired. (`numpy.uint16` has a maximum value of 65535.)

    Returns
    -------
    prior_df : pandas.DataFrame
        Columns are the following:
        [source_id, target_id, edge, source_degree, target_degree, xswap_prior]
    &#34;&#34;&#34;
    # Compute the adjacency matrix of the original (unpermuted) network
    original_edges = xswap.network_formats.edges_to_matrix(
        edge_list, add_reverse_edges=(not allow_antiparallel), shape=shape,
        dtype=dtypes[&#39;edge&#39;], sparse=True)

    # Setup DataFrame for recording prior data
    prior_df = pandas.DataFrame({
        &#39;source_id&#39;: numpy.repeat(numpy.arange(shape[0], dtype=dtypes[&#39;id&#39;]), shape[1]),
        &#39;target_id&#39;: numpy.tile(numpy.arange(shape[1], dtype=dtypes[&#39;id&#39;]), shape[0]),
        &#39;edge&#39;: original_edges.toarray().flatten(),
    })
    del original_edges

    prior_df[&#39;source_degree&#39;] = (prior_df
                                 .groupby(&#39;source_id&#39;)
                                 .transform(sum)[&#39;edge&#39;]
                                 .astype(dtypes[&#39;degree&#39;]))
    del prior_df[&#39;source_id&#39;]

    prior_df[&#39;target_degree&#39;] = (prior_df
                                 .groupby(&#39;target_id&#39;)
                                 .transform(sum)[&#39;edge&#39;]
                                 .astype(dtypes[&#39;degree&#39;]))
    del prior_df[&#39;target_id&#39;]

    # Compute the number of occurrences of each edge across permutations
    edge_counter = compute_xswap_occurrence_matrix(
        edge_list=edge_list, n_permutations=n_permutations, shape=shape,
        allow_self_loops=allow_self_loops, allow_antiparallel=allow_antiparallel,
        swap_multiplier=swap_multiplier, initial_seed=initial_seed,
        max_malloc=max_malloc)

    prior_df[&#39;num_permuted_edges&#39;] = edge_counter.toarray().flatten()
    del edge_counter

    # The number of edges that occurred across all node pairs with the same
    # `source_degree` and `target_degree`
    dgp_edge_count = (
        prior_df
        .groupby([&#39;source_degree&#39;, &#39;target_degree&#39;])
        .transform(sum)[&#39;num_permuted_edges&#39;]
        .values
        .astype(dtypes[&#39;degree&#39;])
    )
    del prior_df[&#39;num_permuted_edges&#39;]

    # The effective number of permutations for every node pair, incorporating
    # degree-grouping
    num_dgp = (
        n_permutations * prior_df.groupby([&#39;source_degree&#39;, &#39;target_degree&#39;])
                                 .transform(len)[&#39;edge&#39;]
                                 .values
    )
    xswap_prior = (dgp_edge_count / num_dgp).astype(dtypes[&#39;xswap_prior&#39;])
    del dgp_edge_count, num_dgp

    prior_df[&#39;xswap_prior&#39;] = xswap_prior
    del xswap_prior

    prior_df = (
        prior_df
        .assign(
            source_id=numpy.repeat(numpy.arange(shape[0], dtype=dtypes[&#39;id&#39;]), shape[1]),
            target_id=numpy.tile(numpy.arange(shape[1], dtype=dtypes[&#39;id&#39;]), shape[0]),
        )
        .filter(items=[&#39;source_id&#39;, &#39;target_id&#39;, &#39;edge&#39;, &#39;source_degree&#39;,
                       &#39;target_degree&#39;, &#39;xswap_prior&#39;])
    )
    return prior_df</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="xswap" href="index.html">xswap</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="xswap.prior.approximate_xswap_prior" href="#xswap.prior.approximate_xswap_prior">approximate_xswap_prior</a></code></li>
<li><code><a title="xswap.prior.compute_xswap_occurrence_matrix" href="#xswap.prior.compute_xswap_occurrence_matrix">compute_xswap_occurrence_matrix</a></code></li>
<li><code><a title="xswap.prior.compute_xswap_priors" href="#xswap.prior.compute_xswap_priors">compute_xswap_priors</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>