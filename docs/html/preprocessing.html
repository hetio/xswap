<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>preprocessing API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>preprocessing</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">import csv


def load_str_edges(filename, node_delim=&#39;,&#39;, edge_delim=&#39;\n&#39;):
    &#34;&#34;&#34;
    Load edges from file into memory. Store edges as a list and store each edge
    as Tuple[str, str]. Used to load edges for preprocessing.
    &#34;&#34;&#34;
    with open(filename, &#39;r&#39;, newline=&#39;&#39;) as f:
        reader = csv.reader(f, delimiter=node_delim, lineterminator=edge_delim)
        str_edges = [tuple(row) for row in reader if len(row) &gt; 1]
    return str_edges


def load_processed_edges(filename):
    &#34;&#34;&#34;
    Load processed edges from a file. Processed means that edges are guaranteed
    to be integers ranging from zero to the number of unique nodes.
    &#34;&#34;&#34;
    str_edges = load_str_edges(filename)
    edges = [
        (int(edge[0]), int(edge[1])) for edge in str_edges
    ]
    return edges


def write_edges(filename, edges, node_delim=&#39;,&#39;, edge_delim=&#39;\n&#39;):
    with open(filename, &#39;w&#39;, newline=&#39;&#39;) as f:
        writer = csv.writer(f, delimiter=node_delim, lineterminator=edge_delim)
        writer.writerows(edges)


def write_mapping(filename, mapping, delimiter=&#39;,&#39;):
    with open(filename, &#39;w&#39;, newline=&#39;&#39;) as f:
        writer = csv.writer(f, delimiter=delimiter)
        writer.writerow([&#39;original&#39;, &#39;mapped&#39;])
        for original, mapped in mapping.items():
            writer.writerow([original, mapped])


def _map_nodes_to_int(nodes):
    &#34;&#34;&#34;
    Return a dict mapping a list of nodes to their sorted indices. Nodes should
    be a list of strings.

    Returns:
    --------
    Dict[str, int]
    &#34;&#34;&#34;
    sorted_node_set = sorted(set(nodes))
    name_to_id = {name: i for i, name in enumerate(sorted_node_set)}
    return name_to_id


def _apply_map(edges, source_mapping, target_mapping):
    &#34;&#34;&#34;
    Maps edges according to new node names specified by source and target maps.

    edges : List[Tuple[str, str]]
    source_mapping : Dict[str, int]
    target_mapping : Dict[str, int]
    &#34;&#34;&#34;
    source_nodes = [edge[0] for edge in edges]
    target_nodes = [edge[1] for edge in edges]
    mapped_nodes = [
        map(source_mapping.get, source_nodes),
        map(target_mapping.get, target_nodes),
    ]
    return list(zip(*mapped_nodes))


def map_str_edges(edges, bipartite):
    &#34;&#34;&#34;
    Maps a list of edge tuples containing strings to a minimal set of
    integer edges.

    edges : List[Tuple[str, str]]
    bipartite : bool
        Whether to map source and target nodes using the same mapping.
        For example, an edge like (&#39;1&#39;, &#39;1&#39;) may refer to a connection between
        separate nodes, or it may be a self-loop. If `bipartite=True`, the
        edge would be mapped like (0, 1), where the new node ids reflect the fact
        that the same names do not indicate the same nodes. To ensure that names
        are consistently mapped between source and target, put `bipartite=False`.

    Returns:
    --------
    Tuple[List[Tuple[int, int]], Dict[int, str]]

    Example:
    --------
    &gt;&gt;&gt; map_str_edges([(&#39;a&#39;, &#39;b&#39;), (&#39;b&#39;, &#39;c&#39;)], bipartite=False)

    ([(0, 1), (1, 2)], {0: &#39;a&#39;, 1: &#39;b&#39;, 2: &#39;c&#39;})
    &#34;&#34;&#34;
    source_nodes = [edge[0] for edge in edges]
    target_nodes = [edge[1] for edge in edges]

    # Two separate mappings to be used for source and target nodes
    if bipartite:
        source_map = _map_nodes_to_int(source_nodes)
        target_map = _map_nodes_to_int(target_nodes)

    # One single mapping to be used for both source and target nodes
    if not bipartite:
        combined_nodes = list(set(source_nodes + target_nodes))
        source_map = target_map = _map_nodes_to_int(combined_nodes)

    mapped_edges = _apply_map(edges, source_map, target_map)
    return (mapped_edges, source_map, target_map)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="preprocessing.load_processed_edges"><code class="name flex">
<span>def <span class="ident">load_processed_edges</span></span>(<span>filename)</span>
</code></dt>
<dd>
<section class="desc"><p>Load processed edges from a file. Processed means that edges are guaranteed
to be integers ranging from zero to the number of unique nodes.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def load_processed_edges(filename):
    &#34;&#34;&#34;
    Load processed edges from a file. Processed means that edges are guaranteed
    to be integers ranging from zero to the number of unique nodes.
    &#34;&#34;&#34;
    str_edges = load_str_edges(filename)
    edges = [
        (int(edge[0]), int(edge[1])) for edge in str_edges
    ]
    return edges</code></pre>
</details>
</dd>
<dt id="preprocessing.load_str_edges"><code class="name flex">
<span>def <span class="ident">load_str_edges</span></span>(<span>filename, node_delim=',', edge_delim='\n')</span>
</code></dt>
<dd>
<section class="desc"><p>Load edges from file into memory. Store edges as a list and store each edge
as Tuple[str, str]. Used to load edges for preprocessing.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def load_str_edges(filename, node_delim=&#39;,&#39;, edge_delim=&#39;\n&#39;):
    &#34;&#34;&#34;
    Load edges from file into memory. Store edges as a list and store each edge
    as Tuple[str, str]. Used to load edges for preprocessing.
    &#34;&#34;&#34;
    with open(filename, &#39;r&#39;, newline=&#39;&#39;) as f:
        reader = csv.reader(f, delimiter=node_delim, lineterminator=edge_delim)
        str_edges = [tuple(row) for row in reader if len(row) &gt; 1]
    return str_edges</code></pre>
</details>
</dd>
<dt id="preprocessing.map_str_edges"><code class="name flex">
<span>def <span class="ident">map_str_edges</span></span>(<span>edges, bipartite)</span>
</code></dt>
<dd>
<section class="desc"><p>Maps a list of edge tuples containing strings to a minimal set of
integer edges.</p>
<p>edges : List[Tuple[str, str]]
bipartite : bool
Whether to map source and target nodes using the same mapping.
For example, an edge like ('1', '1') may refer to a connection between
separate nodes, or it may be a self-loop. If <code>bipartite=True</code>, the
edge would be mapped like (0, 1), where the new node ids reflect the fact
that the same names do not indicate the same nodes. To ensure that names
are consistently mapped between source and target, put <code>bipartite=False</code>.</p>
<h2 id="returns">Returns:</h2>
<p>Tuple[List[Tuple[int, int]], Dict[int, str]]</p>
<h2 id="example">Example:</h2>
<pre><code>&gt;&gt;&gt; map_str_edges([('a', 'b'), ('b', 'c')], bipartite=False)
</code></pre>
<p>([(0, 1), (1, 2)], {0: 'a', 1: 'b', 2: 'c'})</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def map_str_edges(edges, bipartite):
    &#34;&#34;&#34;
    Maps a list of edge tuples containing strings to a minimal set of
    integer edges.

    edges : List[Tuple[str, str]]
    bipartite : bool
        Whether to map source and target nodes using the same mapping.
        For example, an edge like (&#39;1&#39;, &#39;1&#39;) may refer to a connection between
        separate nodes, or it may be a self-loop. If `bipartite=True`, the
        edge would be mapped like (0, 1), where the new node ids reflect the fact
        that the same names do not indicate the same nodes. To ensure that names
        are consistently mapped between source and target, put `bipartite=False`.

    Returns:
    --------
    Tuple[List[Tuple[int, int]], Dict[int, str]]

    Example:
    --------
    &gt;&gt;&gt; map_str_edges([(&#39;a&#39;, &#39;b&#39;), (&#39;b&#39;, &#39;c&#39;)], bipartite=False)

    ([(0, 1), (1, 2)], {0: &#39;a&#39;, 1: &#39;b&#39;, 2: &#39;c&#39;})
    &#34;&#34;&#34;
    source_nodes = [edge[0] for edge in edges]
    target_nodes = [edge[1] for edge in edges]

    # Two separate mappings to be used for source and target nodes
    if bipartite:
        source_map = _map_nodes_to_int(source_nodes)
        target_map = _map_nodes_to_int(target_nodes)

    # One single mapping to be used for both source and target nodes
    if not bipartite:
        combined_nodes = list(set(source_nodes + target_nodes))
        source_map = target_map = _map_nodes_to_int(combined_nodes)

    mapped_edges = _apply_map(edges, source_map, target_map)
    return (mapped_edges, source_map, target_map)</code></pre>
</details>
</dd>
<dt id="preprocessing.write_edges"><code class="name flex">
<span>def <span class="ident">write_edges</span></span>(<span>filename, edges, node_delim=',', edge_delim='\n')</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def write_edges(filename, edges, node_delim=&#39;,&#39;, edge_delim=&#39;\n&#39;):
    with open(filename, &#39;w&#39;, newline=&#39;&#39;) as f:
        writer = csv.writer(f, delimiter=node_delim, lineterminator=edge_delim)
        writer.writerows(edges)</code></pre>
</details>
</dd>
<dt id="preprocessing.write_mapping"><code class="name flex">
<span>def <span class="ident">write_mapping</span></span>(<span>filename, mapping, delimiter=',')</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def write_mapping(filename, mapping, delimiter=&#39;,&#39;):
    with open(filename, &#39;w&#39;, newline=&#39;&#39;) as f:
        writer = csv.writer(f, delimiter=delimiter)
        writer.writerow([&#39;original&#39;, &#39;mapped&#39;])
        for original, mapped in mapping.items():
            writer.writerow([original, mapped])</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="preprocessing.load_processed_edges" href="#preprocessing.load_processed_edges">load_processed_edges</a></code></li>
<li><code><a title="preprocessing.load_str_edges" href="#preprocessing.load_str_edges">load_str_edges</a></code></li>
<li><code><a title="preprocessing.map_str_edges" href="#preprocessing.map_str_edges">map_str_edges</a></code></li>
<li><code><a title="preprocessing.write_edges" href="#preprocessing.write_edges">write_edges</a></code></li>
<li><code><a title="preprocessing.write_mapping" href="#preprocessing.write_mapping">write_mapping</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>